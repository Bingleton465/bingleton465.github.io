<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <title>3D Runner</title> <style> body { margin: 0; overflow: hidden; } canvas { display: block; } </style> </head> <body> <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script> <script> let scene,camera,renderer,clock,player,roadSegments=[],items=[],obstacles=[],lanePositions=[-2,0,2],speed=0.25,spawnInterval=1.2,lastSpawn=0,buttScale=1 init() function init(){ scene=new THREE.Scene() camera=new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,0.1,1000) camera.position.set(0,2,5) renderer=new THREE.WebGLRenderer({antialias:true}) renderer.setSize(window.innerWidth,window.innerHeight) document.body.appendChild(renderer.domElement) clock=new THREE.Clock() const light=new THREE.DirectionalLight(0xffffff,1) light.position.set(0,10,5) scene.add(light) scene.add(new THREE.AmbientLight(0x404040)) createRoad() createPlayer() window.addEventListener('resize',onResize) window.addEventListener('keydown',onKeyDown) animate() } function createRoad(){ const mat=new THREE.MeshStandardMaterial({color:0x555555}) for(let i=0;i<10;i++){ const plane=new THREE.Mesh(new THREE.PlaneGeometry(6,10),mat) plane.rotation.x=-Math.PI/2 plane.position.z=-i*10 scene.add(plane) roadSegments.push(plane) } } function createPlayer(){ player=new THREE.Group() const body=new THREE.Mesh(new THREE.BoxGeometry(1,1.5,1),new THREE.MeshStandardMaterial({color:0x00aaff})) body.position.y=1 player.add(body) const butt=new THREE.Mesh(new THREE.SphereGeometry(0.5,16,16),new THREE.MeshStandardMaterial({color:0xff5555})) butt.position.set(0,0.5,-0.5) butt.name='butt' player.add(butt) player.position.set(0,0,2) scene.add(player) } function onResize(){ camera.aspect=window.innerWidth/window.innerHeight camera.updateProjectionMatrix() renderer.setSize(window.innerWidth,window.innerHeight) } function onKeyDown(e){ if(e.key==='ArrowLeft'){ const idx=lanePositions.indexOf(player.position.x) if(idx>0)player.position.x=lanePositions[idx-1] } if(e.key==='ArrowRight'){ const idx=lanePositions.indexOf(player.position.x) if(idx<lanePositions.length-1)player.position.x=lanePositions[idx+1] } } function spawnObjects(){ const zPos=roadSegments[roadSegments.length-1].position.z-10 lanePositions.forEach(lane=>{ if(Math.random()<0.2){ const broccoli=new THREE.Mesh(new THREE.ConeGeometry(0.3,0.8,8),new THREE.MeshStandardMaterial({color:0x00ff00})) broccoli.position.set(lane,0.4,zPos) broccoli.rotation.x=Math.PI broccoli.name='broccoli' scene.add(broccoli) items.push(broccoli) } if(Math.random()<0.2){ const burger=new THREE.Mesh(new THREE.TorusGeometry(0.4,0.2,16,100),new THREE.MeshStandardMaterial({color:0xffff00})) burger.position.set(lane,0.4,zPos) burger.rotation.x=Math.PI/2 burger.name='burger' scene.add(burger) items.push(burger) } if(Math.random()<0.3){ const obstacle=new THREE.Mesh(new THREE.BoxGeometry(0.8,0.8,0.8),new THREE.MeshStandardMaterial({color:0x333333})) obstacle.position.set(lane,0.4,zPos) obstacle.name='obstacle' scene.add(obstacle) obstacles.push(obstacle) } }) } function animate(){ requestAnimationFrame(animate) const delta=clock.getDelta() moveRoad(delta) moveObjects(delta) spawnControl() checkCollisions() renderer.render(scene,camera) } function moveRoad(delta){ roadSegments.forEach(seg=>{ seg.position.z+=speed if(seg.position.z>5){ seg.position.z=roadSegments[roadSegments.length-1].position.z-10 roadSegments.push(roadSegments.shift()) } }) } function moveObjects(delta){ items.concat(obstacles).forEach(obj=>{obj.position.z+=speed}) items=items.filter(i=>{if(i.position.z>5){scene.remove(i);return false}return true}) obstacles=obstacles.filter(o=>{if(o.position.z>5){scene.remove(o);return false}return true}) } function spawnControl(){ const time=clock.getElapsedTime() if(time-lastSpawn>spawnInterval){ spawnObjects() lastSpawn=time } } function checkCollisions(){ const playerBox=new THREE.Box3().setFromObject(player) for(let i=items.length-1;i>=0;i--){ const item=items[i] const box=new THREE.Box3().setFromObject(item) if(playerBox.intersectsBox(box)){ if(item.name==='broccoli'){ buttScale=Math.max(0.5,buttScale-0.1) } if(item.name==='burger'){ buttScale=Math.min(2,buttScale+0.1) } const butt=player.getObjectByName('butt') butt.scale.set(1,1,buttScale) scene.remove(item) items.splice(i,1) } } obstacles.forEach(o=>{ const box=new THREE.Box3().setFromObject(o) if(playerBox.intersectsBox(box)){ location.reload() } }) } </script> </body> </html>
